everything in javascript happens inside a global execution context   

Javascript is a synchronous and single threaded language.It means JS can execute only one command at a time

execution context is divided into two parts/phases:-
1)memory component/variable environment-> In this phase javascript engine go scan the code and only declare(allocate memory) variables with value=undefined and function with value=whole function.Data/Functions are stored in key value pairs.
2)thread of execution-> In this whole code is executed line by line and variables are intialised value ,functions are called,etc.

Function Invocation:-
Whenever a new function in executed then brand new execution context is created and we again go through the two phases of execution context.
In variable environment parameters and variables will declared with value equal to undefined and then next in thread of execution first of all parameters declared are intialised with value passed to function as argument and then similarly all other variables are initialised value if given and execute function in it.

Call Stack:-
In order handle creation,managment,deletion of execution context.
Global execution context is always at the bottom of stack and other context are pushed into the stack and when they are executed they are popped off

Hosting and Call stack Demo -> https://youtu.be/Fnlnw8uY6jo
When we try to access and log variables and functions before even declaring them it does not throw error rather it logs undefined in the console.
Now this happens because in variable environment phase all variables are declared with undefined and functions are declared with whole function.
Now if we try to access a function created through arrow function and variable then it throws as it is treated as variable and undefined is stored in it and hence it throws that given variable is not a function.
for eg:-
 var getname=()=>{
     console.log("hello world!");
}
Hoisting is a behavior in JavaScript where variables and function declarations are automatically moved to the top of their scope. In other words, regardless of where a variable or function is declared in the code, it is treated as if it was declared at the top of the code block.

Whenever javascript program is executed even with empty js file it js engine creates window object(with some methods and properties) and this keyword.So when you create a variable or function it is added to this window object.
suppose you create a variable x and try to log it on console then you have to do like console.log(window.x) but if you do console.log(x) it will still log x to console cause if you does not provide any object(window object) then it will assume u are pointing to window object

difference between undefined and not defined:-
an variable is undefined if it was allocated placeholder or memory in variable environment and in code it was tried to access its value which is not yet intialised.
an variable is not defined if it was not allocated placeholder or memory during variable environment and hence engine cannot find the the variable in the global space

lexical environment is created Whenever an execution context is created(variable environment) and lexical environment is local memory + reference to lexical environment of parent

Hoisting is also done in let and const variable but we cannot access them before they are intialised.
We can see in the scope(in browser using debugger)...variable declared through var are present in global space but let and const are present something know as script(they are stored in separate memory space).
let and const variables are not attached to global object(window )
Temporal dead zone is the time between since when variable was hoisted till it was intialised

Reference Error:-JS Engine tried to find a variable but was unable to find it.
This error is thrown in the context of let and const variables.
Syntax Error:-This is error is shown if the syntax is wrong for eg:- redeclaring same variable twice but when you declare same variable using var no error is thrown
Type Error:-It is a error thrown for particular type(data type) for eg:- you try to re-intialise the variable intialised with const

Block:-lines of code within a curly braces represent a Block.They are used to represent a multiple lines of code as single line where js engine expects a single statement.Block is used to group the the multiple js statements.
for eg:- a if statement expects single statement after the condition
that is following code is absolute fine
if(true)console.log('single line') 
but we want to do more than one things so we use blocks
if(true){
    console.log('first line');
    console.log('second line');
} 

Block Scope:- what all variable and functions that can be accessed within the block.
Let & const are block scoped while var is not block scoped that is you cannot access let & const variable created in block outside of the block while you can access var variable outside of the block.
for eg:-
{
  let a=1;
  const b=2;
  var c=3;
  console.log(a);//print 1
  console.log(b);//print 2
  console.log(c);//print 3
 }
  console.log(a);//print1
  console.log(b);//throws error
  console.log(c);
 
Now this happens because if you see in the scope using debugger var variable are attached to global scope while for let & const variable a new scope Block is created.

Shadowing:-If we have same named variable outside a particular block then variable inside the block shadows the variable outside the block
for eg:-
let b=1;
{
    let b=2;
    console.log(b)//prints 2 to the console
}
console.log(b)//prints 1 to the console

closure:-function along with its lexical scope forms a closure
Closure :Function bundled with its lexical environment is known as a closure. Whenever function is returned, even if its vanished in execution context but still it remembers the reference it was pointing to
WHEN FUNCTIONS ARE RETURNED THEY STILL MAINTAIN THERE LEXICAL SCOPE,THEY REMEMBER WERE THEY WERE PRESENT

Event Loop has only one job that is continously monitor call stack and callback queue and microtask queue
callback functions from promises and mutation observer come in microtask queue


##Updating objects immutably in react
Even though you updated the object A with the statement A={...A,work:'student'}, you are not actually modifying the original A object. Instead, you are creating a new object that is a copy of the original object A with the additional property work set to 'student'.
This new object is a different object in memory, and the original object A is left untouched. This is the essence of immutability: you create a new object each time you update a state, rather than modifying the existing one. This helps avoid unintentional side effects that could arise if you modify an object directly.
 the original object A is not removed from memory. When you do A = { ...A, work: 'student' }, a new object is created with the properties of the old A object along with a new property work having the value 'student'. The new object is then assigned to the variable A. The old object A still exists in memory until it is no longer referenced anywhere in the code and the garbage collector removes it.
The important thing to note here is that the old object A has not been mutated. Instead, a new object has been created with the updated properties. This is what is meant by "updating objects immutably".

##async and await in javascript
In JavaScript, await is used to wait for a promise to resolve before continuing execution of the current function. When a function contains the await keyword before a promise, the function will pause until the promise is resolved, and then continue execution.

Here's an example:
async function getData() {
  const response = await fetch('/data'); // Wait for the response from the server
  const data = await response.json(); // Wait for the data to be parsed as JSON
  return data;
}

getData().then((data) => {
  console.log(data);
});
In this example, the getData() function is an asynchronous function that uses await to wait for the response from the server and then parse the data as JSON. Once the data is available, the function returns the data. The then() method is then used to log the data to the console.

Note that await can only be used inside an async function. Also, if the promise that await is waiting for is rejected, the async function will throw an error that can be caught using a try/catch block.

You can execute a function that processes the data returned by the fetch promise by chaining the .then() method onto the end of the fetch call.

Here's an example:
fetch('https://api.example.com/data')
  .then(response => response.json())
  .then(data => {
    // Do something with the data
    console.log(data);
  })
  .catch(error => {
    // Handle any errors
    console.error(error);
  });
In this example, the fetch call returns a promise that resolves with a Response object. We chain the .then() method onto the end of the fetch call to extract the JSON data from the response using the json() method. The resulting promise resolves with the parsed data, which we then pass to a function that does something with it. If there is an error, we catch it with the .catch() method.

Using await, the code would look like this:
async function getData() {
  const response = await fetch('https://api.example.com/data');
  const data = await response.json();
  // Do something with the data
  console.log(data);
}

getData().catch(error => {
  // Handle any errors
  console.error(error);
});
In this example, the getData() function is declared as async, which allows us to use await to wait for the response and the data. Once the data is available, we log it to the console. If there is an error, we catch it with a try/catch block.

When you use await with a Promise, it suspends the execution of the current function until the Promise resolves, and then it returns the resolved value.

In the case of fetch, it returns a Promise that resolves with a Response object. To access the response data, you need to call the json() method on the Response object, which also returns a Promise. When you use await with the json() Promise, it suspends the execution of the function until the Promise resolves with the parsed data, and then it returns the data.

##prototypal inheritance
Prototypal inheritance is a way that objects in JavaScript can inherit properties and methods from a parent object, known as the prototype. In this model, each object has a prototype object that it inherits properties and methods from, and can in turn be used as the prototype for other objects.

When a property or method is accessed on an object, if the object itself doesn't have that property or method, JavaScript will look for it on the object's prototype. If it's not found there, the prototype's prototype is searched, and so on, all the way up to the root prototype object.

 When you create an object with a prototype, the prototype object is created only once and all the created objects refer to the same prototype object. This helps to save memory as multiple objects can share the same prototype instead of each having its own copy of the same properties and methods.

For example, in JavaScript, the Object constructor function is used to create objects. When you create an object using the new Object() syntax, the object will have a prototype object. The prototype object for the Object constructor is stored in Object.prototype.

So, if you create five objects using new Object() syntax and set their prototype to Object.prototype, then all five objects will share the same prototype object, which is Object.prototype. This helps to save memory as only one copy of Object.prototype is created and all five objects refer to the same prototype object.
